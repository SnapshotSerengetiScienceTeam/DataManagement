R Code from Ali 

library(plyr)

#### Rolls with Bad Captures ####
RollswBadCaps <- function(y=dat){
     # do you have any captures with too many images?
     bad.ce <- subset(aggregate(image ~ sr, data = y, FUN = max), image > 3)
} 


#### Bad Caps #####    
BadCaps <- function(y=dat, outpath, sx){
     sub <- subset(y, image > 3, select = -c(timestamp, timez))
     badcap <- subset(aggregate(image ~ capture + sr, data = y, FUN = max), image > 3)
     if(dim(badcap)[1] > 0) {
          bad.ce.file <- badcap   
          write.csv(bad.ce.file, paste(outpath, sx, "BadCaps.csv", sep = "")) 
     } else bad.ce.file <- paste("Season", sx, "has no bad captures.")
     print(bad.ce.file)
}

##### Time Checks #####

  

TimeMachine <- function(y=dat, sx, outpath) {
     ## Calculate lag
          y <- y[order(y$site, y$roll, y$ts),]
          y$samesite <- c(T, y$sr[1:length(y$sr)-1] == y$sr[2:length(y$sr)]) # new site?
          y$lag <- 0
          y$lag[2:length(y$J)] <- y$J[2:length(y$J)] - y$J[1:length(y$J)-1] #calculate lag
          y$lag[y$samesite == FALSE] <- 0
          
     y <- subset(y, select = -c(J, samesite)) #dataframe with lags
     if( dim(y[y$lag < 0,])[1] >0)  write.csv(y[y$lag < 0,], paste(outpath, sx, "Reverted.csv", sep = ""))   
     if( dim(y[y$lag >30,])[1] >0)  write.csv(y[y$lag > 30,], paste(outpath, sx, "Leaps.csv", sep = "")) 
     

     lagdf <-  subset(y, lag > 30 | lag <0 )
          lagdf$error[lagdf$lag < 0] <- "revert"
          lagdf$error[lagdf$lag > 30] <- "leap"
     #if(dim(lagdf)[1]== 0) print("There are no lag errors.")
     lagdf <- ddply(lagdf, .(season, site, roll, sr, error), summarize, numpix=length(error), first = first(substr(path,15, 22)))
     #return(lagdf)
}

first <- function(x) x[1]
last <- function(x) x[length(x)]

CalendarCheck <- function(y=dat, sx, outpath){
     bc <- julian(strptime("2010-01-01", format = "%Y-%m-%d"))
     ad <- julian(strptime("2015-01-01", format = "%Y-%m-%d"))
     toosoon <- y[y$J < bc,] # all images with < 2010 timestamps
     toolate <- y[y$J > ad,] # all images with > 2015 timestamps
     if(dim(toosoon)[1] >0) write.csv(toosoon, paste(outpath, sx, "toosoon.csv", sep = "")) 
     if(dim(toolate)[1] >0) write.csv(toolate, paste(outpath, sx, "toolate.csv", sep = "")) 
     badcals <- subset(y, J > ad | J <bc)
     if(dim(badcals)[1] == 0) {
          print("There are no calendar errors")
          cal <- data.frame()
     } else {
          cal <- ddply(subset(y, J > ad | J <bc), .(season, site, roll, sr), summarize, 
                       "numpix"=length(path),
                       "first" = first(substr(path,15, 22)))
          cal$error <- "baddate"
          cal <- cal[, c("season", "site", "roll", "sr", "error", "numpix", "first")]
     }  
     return(cal)
}


MergeErrors <- function(lagdf, badcal, sx, outpath) {
     if(dim(lagdf)[1] == 0 & dim(badcal)[1]>0) {
          rollerrors <- badcal
     } else if(dim(lagdf)[1] > 0 & dim(badcal)[1] == 0) {
          rollerrors <- lagdf    
     } else if(dim(lagdf)[1] == 0 & dim(badcal)[1] == 0) {
          print("Congratulations! There are no calendar or timelag errors left in your dataset")
          rollerrors <- "Congratulations! There are no calendar or timelag errors left in your dataset"
     } else if(dim(lagdf)[1] > 0 & dim(badcal)[1] > 0) {
          if(any(names(lagdf) != names(badcal))) stop("Your data frames are mismatched!")
          rollerrors <-rbind(lagdf, badcal)
     }
     write.csv(rollerrors, paste(outpath, sx, "RollSummary.csv", sep = "")) 
     return(rollerrors)
}

MajorCheck <- function(season){
     # pull in data to check
          inpath = paste("Data/Captures/S", season, "_captures.csv", sep = "")
          outpath = "Data/GenFlag/S"
          
          dat <- read.csv(inpath)
          names(dat) <- c("season", "site", "roll", "capture", "image", "path", "timestamp")
          dat$sr <- paste(dat$site, dat$roll, sep = "_R")
          dat$ts <- dat$timestamp
     
          dat$J <- julian(strptime(dat$ts, format = "%Y:%m:%d %H:%M:%S",tz="Africa/Nairobi")) # ensure datetime ignore dst 
          seasons <- read.csv("Data/seasons.csv")[,1:3]
               
     lagdf <- TimeMachine(dat, sx = season, outpath) #finds season value in   
     badcal <- CalendarCheck(dat, sx = season, outpath)    
     merged <- MergeErrors(lagdf, badcal, sx = season, outpath)   
     print("Your Roll Summary:")
     print(merged)
     return(merged)
}


Protocol from Ali

1) Save all SX_captures.csv to the Data/Captures directory. Note that the script is only designed to automatically handle files with that naming structure. Alternative structures can be used manually.

2) Run ErrorChecking.R.

3) Save the Roll Summary as SXActionList.csv in the ActionLists directory. Add column headings in same format as previous action lists (Action, First/Last/All, Imfrom, Imto, Cap From, Cap To, DateFrom, DateTo, Diff, Comment).

4) Use the interactive code in CheckIndivRoll.R to assess issues with each roll, and identify actions: INVALID (get rid of forever), INVALID2 (maybe with extensive checking of field notes these could be salvageable), INVALID3 (checked the field notes, the hours can't be corrected and thus can't be used for temporal data, but could maybe be used for non-temporal data), TIMECHANGE (will correct time),OK, FLAG (keep an eye on for some reason), ADDRESSED ("ADDRESSED" means that that error has already been taken care of elsewhere in the Action List).

Roll subsets are: ALL, FIRST, LAST, and PARTIAL. This cannot be blank. 

Note that no fixes are run on rolls marked as OK, FLAG, ADDRESSED; doesn't matter if you assign these as all/first/last/partial. 

5) Save ActionList and run Cleaning.R.

6) Run ErrorIterate.R. This also checks for bad captures (which the first one doesn't, because many bad captures are taken care of with the other errors.)
Check to see if the errors need addressing. Add anything to the SXActionList.

7) Rerun ErrorIterate.R as necessary until no errors (that need fixing) remain.

8) Then comes the sucky part. You need to go to the Access database and extract all of the records where the field assistants have entered that they changed times. Season 7 is nice because there are already made columns for TimeFrom and TimeTo. I would suggest exporting this to an excel file or something. Calculate the difference in times. You only need to deal with ones that are more than say, 20 or 30 minutes off. It won't be clear *which* roll these errors belong to; you can figure that out by checking the date of collection against the blackboard photos. They should line up with the blackboard photo SET date of the next roll. It won't be clear *when* the times went bad either. Use the CheckIndivRoll file to see if you can see any weird lags or leaps. Go through the actual photos (using FileZilla) to see if you can pinpoint switches (say, when 1pm became the middle of the night). I have no straightforward methodology, it's just a lot a lot of sleuthing. Once you've figured out what needs to happen with these, add them to the Action List (you'll need to reformat a bit), then re-run the cleaning.R and ErrorIterate.R. As long as nothing new pops up, you're good to go.

